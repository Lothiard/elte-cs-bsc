using System.Drawing;

namespace StateMachineThreaded {

    /// <summary>
    /// A thread-safe signal queue implementation.
    /// </summary>
    /// <typeparam name="TSignal">Type of the signal to be stored in the queue.</typeparam>
    public class SignalQueue<TSignal> {
        private readonly Queue<TSignal> _queue;

        /// <summary>
        /// Exception thrown when attempting to dequeue from an empty signal queue.
        /// </summary>
        public class SignalQueueEmptyException : Exception { }

        /// <summary>
        /// Initializes a new instance of the <see cref="SignalQueue{TSignal}"/> class.
        /// </summary>
        public SignalQueue() {
            _queue = new Queue<TSignal>();
        }

        /// <summary>
        /// Determines whether the queue is empty.
        /// Thread-safe.
        /// </summary>
        /// <returns>True if the queue is empty; otherwise, false.</returns>
        public bool Empty() {
            lock (_queue) {
                return _queue.Count == 0;
            }
        }

        /// <summary>
        /// Adds a signal to the end of the queue.
        /// Thread-safe.
        /// </summary>
        /// <param name="e">Signal to enqueue.</param>
        public void Enqueue(TSignal e) {
            lock (_queue) {
                _queue.Enqueue(e);
            }
        }

        /// <summary>
        /// Removes and returns the signal at the front of the queue.
        /// Throws SignalQueueEmptyException if the queue is empty.
        /// Thread-safe.
        /// </summary>
        /// <returns>The signal at the front of the queue.</returns>
        public TSignal Dequeue() {
            lock (_queue) {
                if (Empty()) {
                    throw new SignalQueueEmptyException();
                }
                return _queue.Dequeue();
            }
        }
    }

    /// <summary>
    /// A generic, multithreaded state machine framework with signal-based transitions.
    /// </summary>
    /// <typeparam name="TState">Enumeration or type representing the states. Must be non-nullable.</typeparam>
    /// <typeparam name="TSignal">Type representing the signals used for transitions. Must be non-nullable.</typeparam>
    public abstract class StateMachineThreaded<TState, TSignal>
        where TState : notnull
        where TSignal : notnull {

        /// <summary>
        /// Exception thrown when an invalid state transition is attempted.
        /// </summary>
        public class InvalidTransitionException : Exception { }

        /// <summary>
        /// Holds information about a valid state transition, including the target state, condition and optional action.
        /// </summary>
        private record TransitionInfo(TState ToState, Func<bool> Condition, Action? OnTransition);

        private readonly Dictionary<(TState, TSignal), List<TransitionInfo>> _stateTransitions;
        private readonly SignalQueue<TSignal> _signalQueue;
        private readonly Thread _thread;
        private readonly TSignal _signalAbort;

        private TState _currentState;

        /// <summary>
        /// Controls if logs generated by the State Machine should be printed instantly or collected.
        /// </summary>
        public bool InstantLogging = false;
        private Queue<(string, ConsoleColor)> _logs;

        /// <summary>
        /// Controls if the State Machine should log messages or not.
        /// </summary>
        public bool Verbose = true;

        /// <summary>
        /// Gets the current active state of the state machine.
        /// </summary>
        public TState CurrentState => _currentState;

        /// <summary>
        /// Initializes a new instance of the <see cref="StateMachineThreaded{TState, TSignal}"/> class.
        /// </summary>
        /// <param name="startState">Initial state of the state machine.</param>
        /// <param name="abortSignal">Special signal used to terminate the state machine.</param>
        protected StateMachineThreaded(TState startState, TSignal abortSignal) {
            _logs = new();
            _stateTransitions = new();
            _signalQueue = new();
            _currentState = startState;
            _signalAbort = abortSignal;
            _thread = new Thread(StateMachineProcess);
        }

        /// <summary>
        /// The main processing loop of the state machine.
        /// Dequeues and processes signals until the abort signal is received.
        /// </summary>
        private void StateMachineProcess() {
            while (true) {
                TSignal signal = default!;
                try {
                    signal = _signalQueue.Dequeue();

                    if (signal.Equals(_signalAbort)) {
                        break;
                    }

                    ProcessSignal(signal);
                } catch (SignalQueue<TSignal>.SignalQueueEmptyException) {
                    Loop(_currentState);
                    continue;
                } catch (InvalidTransitionException) {
                    // Optional: log, rethrow, or ignore invalid transitions
                    // Console.WriteLine($"[ERR] Invalid transition from [{_currentState}] on signal [{signal}]");
                    // throw;
                }
            }
        }

        /// <summary>
        /// Registers a transition between two states triggered by a specific signal.
        /// </summary>
        /// <param name="fromState">State to transition from.</param>
        /// <param name="signal">Signal that triggers the transition.</param>
        /// <param name="toState">State to transition to.</param>
        /// <param name="condition">Predicate function that determines whether the transition should occur based on the current context.</param>
        /// <param name="onTransition">Optional action to execute during the transition.</param>
        protected void AddTransition(TState fromState, TSignal signal, TState toState, Func<bool> condition, Action? onTransition = null) {
            var key = (fromState, signal);
            TransitionInfo info = new TransitionInfo(toState, condition, onTransition);

            if (!_stateTransitions.ContainsKey(key)) {
                _stateTransitions[key] = new List<TransitionInfo>();
            }

            _stateTransitions[key].Add(info);
        }

        /// <summary>
        /// Registers a transition between two states triggered by a specific signal.
        /// </summary>
        /// <param name="fromState">State to transition from.</param>
        /// <param name="signal">Signal that triggers the transition.</param>
        /// <param name="toState">State to transition to.</param>
        /// <param name="onTransition">Optional action to execute during the transition.</param>
        protected void AddTransition(TState fromState, TSignal signal, TState toState, Action? onTransition = null) {
            AddTransition(fromState, signal, toState, () => true, onTransition);
        }

        /// <summary>
        /// Determines whether more than one transition in the given list has a condition that evaluates to true.
        /// </summary>
        /// <param name="transitions">A list of transitions to evaluate.</param>
        /// <returns>
        /// True if more than one transition has a true condition; otherwise, false.
        /// </returns>
        private static bool HasMultipleTrueConditions(List<TransitionInfo> transitions) {
            int count = 0;
            foreach (var transition in transitions) {
                if (transition.Condition()) {
                    count++;
                    if (count > 1) {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Processes a signal and transitions to the next state if a valid transition is defined.
        /// </summary>
        /// <param name="signal">Signal to process.</param>
        /// <exception cref="InvalidTransitionException">Thrown if the transition is not defined.</exception>
        private void ProcessSignal(TSignal signal) {
            var key = (_currentState, signal);
            if (_stateTransitions.TryGetValue(key, out var transitions)) {
                if (HasMultipleTrueConditions(transitions)) {
                    if (Verbose) {
                        Log($"<{GetType().Name}> [ERROR] Ambiguous transition detected for signal '{signal}' from state '{_currentState}'", ConsoleColor.Red);
                    }
                    return;
                }

                foreach (var transition in transitions) {
                    if (transition.Condition()) {
                        if (Verbose) {
                            Log($"<{GetType().Name}> [Transition] {_currentState} --[{signal}]--> {transition.ToState}", ConsoleColor.Green);
                        }

                        OnLeave(_currentState);
                        transition.OnTransition?.Invoke();
                        _currentState = transition.ToState;
                        OnEnter(_currentState);
                        break;
                    }
                }
            } else {
                throw new InvalidTransitionException();
            }
        }

        /// <summary>
        /// Logs a message to the console using the specified text color.
        /// </summary>
        /// <param name="message">The message to be displayed in the console.</param>
        /// <param name="color">
        /// Optional. The color to use when displaying the message. Defaults to <see cref="ConsoleColor.DarkGray"/>.
        /// </param>
        private void Log(string message, ConsoleColor color = ConsoleColor.DarkGray) {
            _logs.Enqueue((message, color));
            if (InstantLogging) {
                FlushLogs();
            }
        }

        public void FlushLogs() {
            while(_logs.Count > 0) {
                (string message, ConsoleColor color) = _logs.Dequeue();
                Console.ForegroundColor = color;
                Console.WriteLine(message);
                Console.ResetColor();
            }
        }

        /// <summary>
        /// Starts the state machine thread.
        /// </summary>
        public void Start() {
            _thread.Start();
        }

        /// <summary>
        /// Sends a signal to the state machine to be processed.
        /// </summary>
        /// <param name="signal">Signal to send.</param>
        public void SendSignal(TSignal signal) {
            _signalQueue.Enqueue(signal);
        }

        /// <summary>
        /// Called when entering a new state.
        /// Override this to provide custom behavior.
        /// </summary>
        /// <param name="state">State being entered.</param>
        public virtual void OnEnter(TState state) { }

        /// <summary>
        /// Called continuously while in a state when no signal is available.
        /// Override this to provide custom behavior (e.g., polling, timeouts).
        /// </summary>
        /// <param name="state">Current state.</param>
        public virtual void Loop(TState state) { }

        /// <summary>
        /// Called before leaving the current state.
        /// Override this to provide custom behavior.
        /// </summary>
        /// <param name="state">State being left.</param>
        public virtual void OnLeave(TState state) { }
    }
}
